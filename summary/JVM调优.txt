JVM调优 http://blog.csdn.net/liang0000zai/article/details/50040227
	tomcat如何设置jvm参数：
	在bin目录中找到(catalina.sh)编辑这个文件，
	找到JAVA_OPTS选项
	设置参数，重启服务器生效。也可以配置系统变量，但这种方式需要重启机器。

非堆内存(持久代)的设置：方法区大小。持久带的大小直接决定了系统可以支持多少个类和变量。尤其是需要动态生成class类的时候比如cglib
-XX:PermSize=64M JVM初始分配的非堆内存 
-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配 




如何判断一个对象是否需要被gc？
1.引用计数法：给对象添加一个引用计数器，有引用加一，引用失效减一，0则回收。但这种方式不能解决对象互相依赖问题。
2.可达性算法：当一个对象没有被任何GC ROOT引用的时候会被gc
  GC ROOT： 1.虚拟机栈(栈帧中的本地变量表)中引用的对象。
			2.方法区中类静态属性引用的对象。
			3.方法区中常量引用的对象。
			4.本地方法栈中JNI(即一般说的Native方法)引用的对象。


1.Java栈内存的的设置 -Xss参数 设置每个线程的堆栈大小，默认1M，
如果应用的线程所需的内存空间很大的话，需要调大
但如果系统线程个数很多的情况下，则需要调小
比如函数嵌套调用的次数过多，递归调用的层数过多，可以设置此参数来优化。

2.堆内存
	新生代：eden,survivor space0,survivor space1
	年老代：

堆内存大小设置：-Xms(堆初始大小) -Xmx(最大申请空间)
		一般把-Xms 跟-Xmx设置成相同大小，以避免每次垃圾回收完成后JVM重新分配内存。
		sun的jdk建议设置相同，因为采用的是分代回收的策略
		ibm jdk
设置年轻代大小：-Xmn  新生代一半占堆空间的1/3~1/4。 年轻代过小会导致Minor GC回收频繁
			所以对于响应时间要求很高的应用，年轻代的大小设置较大，可以减少垃圾回收次数，并避免对象进入年老代full gc
年老代的回收：Major GC 
整个堆大小=年轻代大小 + 年老代大小 + 持久代大小

设置堆得比例分配：-XX:SurvivorRatio用来设置比例，这个比例就是eden/s0的大小，s0,s1一致


回收器选择
JVM给了三种选择：串行收集器、并行收集器、并发收集器
串行收集器：只适用于小数据量的情况，1.5之前
JDK5.0以后，JVM会根据当前系统配置进行判断

并行收集器：并主要以到达一定的吞吐量为目标，适用于大量数据计算和一些后台处理

并发收集器：主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。

对于吞吐量优先的系统：设置年轻代为并行收集器，年老代为串行收集器。

对于响应优先的系统：要减少垃圾收集的停顿时间，同时减少垃圾回收的次数
设置年轻代为并行收集(结合CMS收集)，设置呢年老代为并发收集。
设置年老代为并发收集后，由于并发收集不会对内存空间压缩和整理。可以打开年老代压缩的开关，但这可能会影响效率。

使用jps命令查看当前java进程（类似于linux的ps命令）
jstack 导出进程内的线程堆栈
用jmap生成java应用程序的堆栈信息（pid,进程）
jmap生成后，dump堆栈信息到文件
使用jhat命令去分析这个文件，展示，http服务器，在浏览器中访问即可。

查看jvm gc回收时间：jstat 
YGC :年轻代回收次数
YGCT：年轻代回收时间








