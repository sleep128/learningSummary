一：RocketMQ怎么实现发送顺序消息?
	1.RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。
	2.在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。

二：RocketMQ是怎样解决消息重复的问题呢？
	1.问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？
		a.消费端处理消息的业务逻辑保持幂等性
        b.保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
        		第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。

				第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。

				结论：RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。

三：事务消息
	总共分为3个阶段：发送Prepared消息、执行本地事务、发送确认消息。
	RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。

	如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

四：消息存储
	RocketMQ的消息存储是由consume queue和commit log配合完成的。

五：消息订阅
	RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送
	另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式。

	消费端负载均衡：

    遍历Consumer下的所有topic，然后根据topic订阅所有的消息
    获取同一topic和Consumer Group下的所有Consumer
    然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等

	平均分配策略，它类似于分页的过程，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列