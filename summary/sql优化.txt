sql 优化

1.避免使用select * ,查询字段需要什么取什么。
2.对于查找有无得sql，使用limit 1查询，效率更快。
3.使用表的别名，当sql语句连接多张表时，使用表别名可以降低sql解析时间并防止歧义


Mysql:
1.使用EXPLAIN分析sql语句。查看sql索引使用情况
2.根据实际应用场景建立索引。
3.避免在索引列使用函数或计算，会导致全表扫描
4like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
5.只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL


数据库隔离机制：
1、未提交读(Read Uncommitted)    会脏读，当前事务未提交的数据会被其他事务看到 
2、提交读(Read Committed)        不会脏读，当前事务未提交不会被其他事务看到。不可重复读，及前后读取会不一致
3、可重复读(Repeatable Read)    A事务中的数据不会受B事务影响，前后保持一致。产生幻读
4、串行读(Serializable)           不允许同时有多个事务操作该表


https://monkeysayhi.github.io/2018/03/06/%E6%B5%85%E8%B0%88MySQL%E7%9A%84B%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io

Mysql innoDb引擎，默认使用B+树索引
最左前缀匹配 https://tech.meituan.com/mysql-index.html

最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
建立组合索引(a,b,c,d)
如果 where a=1 and b=2 and c=3 and d>4  这样是没有问题的，且a,b,c的顺序可以是乱序
如果 where a=1 and b=2 and c>3 and d=4  这样，c的索引其实没有走到，需要建成(a,b,d,c),

1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，
如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可









